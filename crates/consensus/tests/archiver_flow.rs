//! Archiver flow integration tests.
//!
//! Tests for archive notice handling/storage and metrics recording.

mod common;

use color_eyre::Result;
use common::{
    TestDirs, build_seeded_state, make_genesis, mocks::MockExecutionNotifier,
    propose_with_optional_blobs, sample_blob_bundle, sample_execution_payload_v3_for_height,
};
use malachitebft_app_channel::app::types::core::{CommitCertificate, Round};
use ultramarine_blob_engine::BlobEngine;
use ultramarine_types::height::Height;

/// Test that archive notices are properly stored and can be loaded.
///
/// Archive notices are now ONLY generated by the archiver worker after real uploads.
/// This test simulates the archiver worker path by manually creating and storing notices.
#[tokio::test]
async fn archive_notices_stored_and_loadable() -> Result<()> {
    use ultramarine_types::{
        archive::{ArchiveNotice, ArchiveNoticeBody},
        signing::Ed25519Provider,
    };

    let (genesis, validators) = make_genesis(1);
    let validator = &validators[0];
    let dirs = TestDirs::new();

    let mut node = build_seeded_state(&dirs, &genesis, validator, Height::new(0)).await?;

    // Propose and commit a height with blobs
    let height = Height::new(0);
    let round = Round::new(0);
    let bundle = sample_blob_bundle(2);

    let payload = sample_execution_payload_v3_for_height(height, Some(&bundle));
    let (proposed, bytes, maybe_sidecars) =
        propose_with_optional_blobs(&mut node.state, height, round, &payload, Some(&bundle))
            .await?;
    let sidecars = maybe_sidecars.expect("blobbed proposal should yield sidecars");

    node.state.blob_engine().verify_and_store(height, round.as_i64(), &sidecars).await?;
    node.state.store_undecided_block_data(height, round, bytes.clone(), Vec::new()).await?;

    let certificate = CommitCertificate {
        height,
        round,
        value_id: proposed.value.id(),
        commit_signatures: Vec::new(),
    };
    let mut notifier = MockExecutionNotifier::default();
    node.state.process_decided_certificate(&certificate, bytes, &mut notifier).await?;

    // Simulate archiver worker: create and handle archive notices
    let signer = Ed25519Provider::new(validator.private_key());
    for (idx, sidecar) in sidecars.iter().enumerate() {
        let body = ArchiveNoticeBody {
            height,
            round,
            blob_index: idx as u16,
            kzg_commitment: sidecar.kzg_commitment.clone(),
            blob_keccak: sidecar.blob.keccak_hash(),
            provider_id: "test-provider".to_string(),
            locator: format!("test://height_{}/blob_{}", height.as_u64(), idx),
            archived_by: validator.address(),
            archived_at: 12345,
        };
        let notice = ArchiveNotice::sign(body, &signer);
        node.state.handle_archive_notice(notice).await?;
    }

    // Load archive notices for this height
    let loaded_notices = node.state.load_archive_notices(height).await?;
    assert_eq!(loaded_notices.len(), 2, "should have stored 2 archive notices");

    // Verify loaded notices have correct height and indices
    for notice in &loaded_notices {
        assert_eq!(notice.body.height, height);
        assert!(notice.body.blob_index < 2);
    }

    Ok(())
}

/// Test that archive notices signed by non-proposers are rejected.
#[tokio::test]
async fn archive_notices_reject_non_proposer() -> Result<()> {
    use ultramarine_types::{
        archive::{ArchiveNotice, ArchiveNoticeBody},
        signing::Ed25519Provider,
    };

    let (genesis, validators) = make_genesis(2);
    let proposer = &validators[0];
    let other_validator = &validators[1];
    let dirs = TestDirs::new();

    let mut node = build_seeded_state(&dirs, &genesis, proposer, Height::new(0)).await?;

    let height = Height::new(0);
    let round = Round::new(0);
    let bundle = sample_blob_bundle(1);

    let payload = sample_execution_payload_v3_for_height(height, Some(&bundle));
    let (proposed, bytes, maybe_sidecars) =
        propose_with_optional_blobs(&mut node.state, height, round, &payload, Some(&bundle))
            .await?;
    let sidecars = maybe_sidecars.expect("blobbed proposal should yield sidecars");

    node.state.blob_engine().verify_and_store(height, round.as_i64(), &sidecars).await?;
    node.state.store_undecided_block_data(height, round, bytes.clone(), Vec::new()).await?;

    let certificate = CommitCertificate {
        height,
        round,
        value_id: proposed.value.id(),
        commit_signatures: Vec::new(),
    };
    let mut notifier = MockExecutionNotifier::default();
    node.state.process_decided_certificate(&certificate, bytes, &mut notifier).await?;

    let mut body = ArchiveNoticeBody {
        height,
        round,
        blob_index: 0,
        kzg_commitment: sidecars[0].kzg_commitment.clone(),
        blob_keccak: sidecars[0].blob.keccak_hash(),
        provider_id: "test-provider".to_string(),
        locator: "test://reject".to_string(),
        archived_by: other_validator.address(),
        archived_at: 42,
    };

    // Sign notice with non-proposer validator.
    let signer = Ed25519Provider::new(other_validator.private_key());
    let notice = ArchiveNotice::sign(body.clone(), &signer);

    let err = node
        .state
        .handle_archive_notice(notice)
        .await
        .expect_err("non-proposer notice should be rejected");
    assert!(err.to_string().contains("does not match proposer"), "unexpected error: {err:?}");

    // Ensure proposer-signed notice is accepted to prove the height can still progress.
    body.archived_by = proposer.address();
    let proposer_notice = ArchiveNotice::sign(body, &Ed25519Provider::new(proposer.private_key()));
    node.state.handle_archive_notice(proposer_notice).await?;

    Ok(())
}

/// Test that archiver_enabled flag correctly gates synchronous notice generation.
#[tokio::test]
async fn archiver_enabled_gates_sync_notices() -> Result<()> {
    let (genesis, validators) = make_genesis(1);
    let validator = &validators[0];
    let dirs = TestDirs::new();

    let mut node = build_seeded_state(&dirs, &genesis, validator, Height::new(0)).await?;

    // Enable archiver mode before first commit
    node.state.set_archiver_enabled(true);

    let height = Height::new(0);
    let round = Round::new(0);
    let bundle = sample_blob_bundle(1);

    let payload = sample_execution_payload_v3_for_height(height, Some(&bundle));
    let (proposed, bytes, maybe_sidecars) =
        propose_with_optional_blobs(&mut node.state, height, round, &payload, Some(&bundle))
            .await?;
    let sidecars = maybe_sidecars.expect("blobbed proposal should yield sidecars");

    node.state.blob_engine().verify_and_store(height, round.as_i64(), &sidecars).await?;
    node.state.store_undecided_block_data(height, round, bytes.clone(), Vec::new()).await?;

    let certificate = CommitCertificate {
        height,
        round,
        value_id: proposed.value.id(),
        commit_signatures: Vec::new(),
    };
    let mut notifier = MockExecutionNotifier::default();
    node.state.process_decided_certificate(&certificate, bytes, &mut notifier).await?;

    // With archiver_enabled, no sync notices should be generated
    let loaded_notices = node.state.load_archive_notices(height).await?;
    assert!(loaded_notices.is_empty(), "archiver_enabled should prevent sync notice generation");

    // But build_archive_job should return a valid job
    let job = node.state.build_archive_job(height, round).await?;
    assert!(job.is_some(), "build_archive_job should return a job");
    let job = job.unwrap();
    assert_eq!(job.blob_indices.len(), 1);

    Ok(())
}
